<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HgCdTe Zincblende Structure Viewer</title>
  <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background-color: #fafafa;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #viewer {
      flex: 1;
      position: relative;
    }
    #controls {
      width: 270px;
      padding: 20px;
      background-color: white;
      border-left: 1px solid #eaeaea;
      overflow-y: auto;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
    }
    .control-group {
      margin-bottom: 20px;
    }
    .control-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }
    button {
      padding: 6px 12px;
      margin: 4px;
      cursor: pointer;
      background-color: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      transition: all 0.2s;
      font-size: 14px;
    }
    button:hover {
      background-color: #e9e9e9;
    }
    button.active {
      background-color: #e0e0e0;
      border-color: #c0c0c0;
    }
    .slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #e0e0e0;
      outline: none;
      border-radius: 3px;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #4a90e2;
      cursor: pointer;
    }
    .info-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      max-width: 300px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .info-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #333;
    }
    .legend {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      margin-right: 8px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    hr {
      border: none;
      border-top: 1px solid #eaeaea;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="viewer">
      <div class="info-panel">
        <h3>HgCdTe Zincblende Structure</h3>
        <div id="lattice-info">Lattice constant: 6.46 Å</div>
        <div id="composition-info">Composition: Hg<sub>0.7</sub>Cd<sub>0.3</sub>Te</div>
        <div>Space group: F-43m (216)</div>
        <hr>
        <div class="legend">
          <div class="legend-color" style="background-color:#FF5252;"></div>
          <div>Hg</div>
        </div>
        <div class="legend">
          <div class="legend-color" style="background-color:#FFD740;"></div>
          <div>Cd</div>
        </div>
        <div class="legend">
          <div class="legend-color" style="background-color:#40C4FF;"></div>
          <div>Te</div>
        </div>
      </div>
    </div>
    <div id="controls">
      <h2>Controls</h2>

      <div class="control-group">
        <div class="control-title">Composition (x in Hg₁₋ₓCdₓTe)</div>
        <input type="range" id="composition" class="slider" min="0" max="1" step="0.1" value="0.3">
        <div id="composition-value">x = 0.3</div>
      </div>

      <div class="control-group">
        <div class="control-title">Visualization</div>
        <button id="btn-stick">Stick</button>
        <button id="btn-ball-stick" class="active">Ball & Stick</button>
        <button id="btn-spacefill">Spacefill</button>
      </div>

      <div class="control-group">
        <div class="control-title">Unit Cell</div>
        <button id="btn-show-cell">Show Unit Cell</button>
        <button id="btn-hide-cell" class="active">Hide Unit Cell</button> </div>

      <div class="control-group">
        <div class="control-title">Labels</div>
        <button id="btn-show-labels">Show Labels</button>
        <button id="btn-hide-labels" class="active">Hide Labels</button> </div>

      <div class="control-group">
        <div class="control-title">Supercell</div>
        <button id="btn-1x1x1" class="active">1×1×1</button>
        <button id="btn-2x2x2">2×2×2</button>
      </div>

      <div class="control-group">
        <div class="control-title">Animation</div>
        <button id="btn-spin">Spin</button>
        <button id="btn-stop">Stop</button>
      </div>

      <div class="control-group">
        <div class="control-title">Export</div>
        <button id="btn-screenshot">Screenshot</button>
      </div>

      <div class="control-group">
        <div class="control-title">Structure Information</div>
        <p><strong>HgCdTe (Hg₁₋ₓCdₓTe)</strong></p>
        <p>- Ternary semiconductor alloy</p>
        <p>- Zincblende structure (F-43m)</p>
        <p>- Used in infrared detectors</p>
        <p>- Bandgap: 0 to 1.5 eV (tunable)</p>
        <p>- Applications: IR imaging, photonics</p>
      </div>
    </div>
  </div>

  <script>
    $(document).ready(function() {
      // Initialize the viewer
      let element = $("#viewer");
      let config = {
        backgroundColor: "white",
        antialias: true
      };

      let viewer = $3Dmol.createViewer(element, config);

      // Define lattice constants for HgTe and CdTe
      const a_HgTe = 6.46; // Å
      const a_CdTe = 6.48; // Å
      let latticeConstant = a_HgTe; // Initial value (will be updated)

      // HgCdTe colors
      const atomColors = {
        "Hg": "#FF5252", // Bright red
        "Cd": "#FFD740", // Bright gold/yellow
        "Te": "#40C4FF"  // Bright blue
      };

      // Track state
      let labelsShown = false;
      let cellShown = false;
      let atomLabels = []; // Store label objects/IDs
      let cellLines = [];  // Store shape IDs for cell lines
      let cellLabel = null; // Store shape ID for cell label

      // Current state tracking
      let currentViewStyle = "ballAndStick";
      let currentSupercell = 1;
      let currentAtoms = []; // Store the latest generated atom data

      // Function to generate atom data for HgCdTe
      function generateAtomData(cdRatio = 0.3, cellSize = 1) {
        let atoms = [];
        // Calculate lattice constant based on current composition for atom placement
        const currentLatticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;

        // Generate supercell
        for (let i = 0; i < cellSize; i++) {
          for (let j = 0; j < cellSize; j++) {
            for (let k = 0; k < cellSize; k++) {
              // Base positions for zincblende structure (fractional coordinates)
              let cationPositions = [
                [0, 0, 0], [0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]
              ];
              let anionPositions = [
                [0.25, 0.25, 0.25], [0.25, 0.75, 0.75], [0.75, 0.25, 0.75], [0.75, 0.75, 0.25]
              ];

              // Add cations (Hg and Cd based on composition)
              cationPositions.forEach(pos => {
                let elemType = Math.random() < cdRatio ? "Cd" : "Hg";
                atoms.push({
                  elem: elemType,
                  x: (pos[0] + i) * currentLatticeConstant,
                  y: (pos[1] + j) * currentLatticeConstant,
                  z: (pos[2] + k) * currentLatticeConstant,
                  serial: atoms.length // Unique ID if needed later
                });
              });

              // Add anions (Te)
              anionPositions.forEach(pos => {
                atoms.push({
                  elem: "Te",
                  x: (pos[0] + i) * currentLatticeConstant,
                  y: (pos[1] + j) * currentLatticeConstant,
                  z: (pos[2] + k) * currentLatticeConstant,
                  serial: atoms.length
                });
              });
            }
          }
        }
        return atoms;
      }

      // Function to add atom labels
      function addAtomLabels() {
        // Clear previous atom labels
        for (let label of atomLabels) {
           viewer.removeLabel(label);
        }
        atomLabels = [];
        // Exit if labels not shown or no atoms generated yet
        if (!labelsShown || !currentAtoms || currentAtoms.length === 0) return;

        // Calculate center based on overall supercell dimensions for label offset direction
        const center = {
            x: (currentSupercell * latticeConstant) / 2,
            y: (currentSupercell * latticeConstant) / 2,
            z: (currentSupercell * latticeConstant) / 2
        };

        // Only label atoms from the first unit cell equivalent for clarity
        const baseCellLimit = latticeConstant; // Use the calculated lattice constant
        currentAtoms.forEach(atom => {
          // Check if atom is within the conceptual "first" unit cell boundaries
          if (atom.x < baseCellLimit && atom.y < baseCellLimit && atom.z < baseCellLimit) {
                // Calculate offset direction (simple radial outward)
                let dx = atom.x - center.x;
                let dy = atom.y - center.y;
                let dz = atom.z - center.z;
                let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                const offsetFactor = 1.5; // How far label is from atom center
                let labelPos = { x: atom.x, y: atom.y, z: atom.z };

                if (dist > 0.01) { // Avoid division by zero
                    labelPos.x += (dx / dist) * offsetFactor;
                    labelPos.y += (dy / dist) * offsetFactor;
                    labelPos.z += (dz / dist) * offsetFactor;
                } else { // Default offset if atom is effectively at center
                   labelPos.x += offsetFactor;
                }

               let labelId = viewer.addLabel(atom.elem, {
                   position: labelPos,
                   backgroundColor: "rgba(255, 255, 255, 0.7)",
                   fontColor: "#333333",
                   fontSize: 12,
                   showBackground: true,
                   backgroundOpacity: 0.5
                });
               atomLabels.push(labelId); // Store the label ID
            }
        });
      }

      // Function to draw unit cell outline
      function drawUnitCellOutline() {
        // Remove previous cell lines and label
        for (let lineId of cellLines) {
          viewer.removeShape(lineId);
        }
        cellLines = [];
        if (cellLabel) {
          viewer.removeLabel(cellLabel);
          cellLabel = null;
        }

        if (!cellShown) return; // Don't draw if not shown

        const cellLength = latticeConstant * currentSupercell; // Use current lattice const and supercell size

        // Define cell vertices relative to origin (0,0,0)
        const vertices = [
          [0, 0, 0], [cellLength, 0, 0], [0, cellLength, 0], [cellLength, cellLength, 0],
          [0, 0, cellLength], [cellLength, 0, cellLength], [0, cellLength, cellLength], [cellLength, cellLength, cellLength]
        ];

        // Define edges connecting vertices
        const edges = [
          [0, 1], [0, 2], [1, 3], [2, 3], [4, 5], [4, 6], [5, 7], [6, 7],
          [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        // Draw cell edges
        edges.forEach(edge => {
            const start = { x: vertices[edge[0]][0], y: vertices[edge[0]][1], z: vertices[edge[0]][2] };
            const end = { x: vertices[edge[1]][0], y: vertices[edge[1]][1], z: vertices[edge[1]][2] };

             let lineId = viewer.addCylinder({ // Use cylinder for lines
                 start: start,
                 end: end,
                 radius: 0.05, // Thin radius for outline
                 color: "#555555", // Dark grey color
                 dashed: true, // Make it dashed
                 dashLength: 0.4,
                 gapLength: 0.2
            });
             cellLines.push(lineId); // Store the ID to remove later
         });

        // Add lattice constant label near the cell (only for 1x1x1 for clarity)
        if (currentSupercell === 1) {
            cellLabel = viewer.addLabel(`a = ${latticeConstant.toFixed(2)} Å`, {
              position: { x: cellLength / 2, y: -1.0, z: -1.0 }, // Adjusted position
              backgroundColor: "rgba(255, 255, 255, 0.8)",
              fontColor: "#333333",
              fontSize: 14,
              showBackground: true,
              backgroundOpacity: 0.8
            });
        }
      }

      // *** CENTRAL RENDER FUNCTION ***
      function renderStructure() {
        // 1. Clear previous models, shapes, and labels
        viewer.removeAllModels();
        viewer.removeAllShapes(); // Clear any manually added shapes
        for (let label of atomLabels) viewer.removeLabel(label);
        atomLabels = [];
        for (let lineId of cellLines) viewer.removeShape(lineId);
        cellLines = [];
        if (cellLabel) viewer.removeLabel(cellLabel);
        cellLabel = null;

        // 2. Update composition and calculate current lattice constant
        let cdRatio = parseFloat($("#composition").val());
        latticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio; // Update global latticeConstant for use elsewhere
        $("#composition-value").text(`x = ${cdRatio.toFixed(1)}`);
        $("#composition-info").html(`Composition: Hg<sub>${(1-cdRatio).toFixed(1)}</sub>Cd<sub>${cdRatio.toFixed(1)}</sub>Te`);
        $("#lattice-info").text(`Lattice constant: ${latticeConstant.toFixed(2)} Å`);

        // 3. Generate new atom data using the latest composition ratio
        currentAtoms = generateAtomData(cdRatio, currentSupercell);
        if (currentAtoms.length === 0) {
            viewer.render(); // Render empty viewer if no atoms
            return;
        }

        // 4. Add atoms as a model
        let model = viewer.addModel();
        model.addAtoms(currentAtoms);

        // 5. Apply visualization style
        let style = {};
        const baseStickRadius = 0.1;
        const ballScale = 0.35;

        // Define the common color scheme structure ONCE
        const colorScheme = {
            prop: 'elem',
            map: atomColors
        };

        // --- Corrected Style Application ---
        switch (currentViewStyle) {
          case "stick":
            style = {
              stick: {
                radius: baseStickRadius,
                colorscheme: colorScheme // Apply colorscheme TO STICKS
              }
              // Optional: hide spheres explicitly if needed, though usually stick implies atoms at vertices
              // sphere: {hidden: true}
            };
            break;
          case "ballAndStick":
            style = {
              stick: {
                radius: baseStickRadius,
                colorscheme: colorScheme // Apply colorscheme TO STICKS
              },
              sphere: {
                scale: ballScale,
                colorscheme: colorScheme // Apply colorscheme TO SPHERES
              }
            };
            break;
          case "spacefill":
            style = {
              sphere: {
                // Use default vdW radius
                colorscheme: colorScheme // Apply colorscheme TO SPHERES
              }
            };
            break;
        }

        // Apply the constructed style object
        viewer.setStyle({}, style);
        // --- End Corrected Style Application ---

        // 6. Add Unit Cell if shown
        if (cellShown) {
          drawUnitCellOutline();
        }

        // 7. Add Labels if shown
        if (labelsShown) {
           addAtomLabels();
        }

        // 8. Zoom and render the scene
        viewer.zoomTo(); // Adjust camera to fit the structure
        viewer.render();
      }

      // Function to update active button styling
      function updateActiveButtons(group, activeButton) {
        let buttons;
        switch (group) {
            case "visualization":
                buttons = "#btn-stick, #btn-ball-stick, #btn-spacefill";
                break;
            case "supercell":
                buttons = "#btn-1x1x1, #btn-2x2x2";
                break;
            case "labels":
                buttons = "#btn-show-labels, #btn-hide-labels";
                break;
            case "cell":
                buttons = "#btn-show-cell, #btn-hide-cell";
                break;
            default:
                return; // Unknown group
        }
        $(buttons).removeClass("active");
        $(activeButton).addClass("active");
      }

      // Initial render
      renderStructure();
      // Set initial active state for hide buttons
      updateActiveButtons("labels", "#btn-hide-labels");
      updateActiveButtons("cell", "#btn-hide-cell");


      // --- Event listeners ---
      $("#composition").on("input", function() {
        renderStructure(); // Redraw everything on composition change
      });

      $("#btn-stick").click(function() {
        if (currentViewStyle !== "stick") {
            currentViewStyle = "stick";
            updateActiveButtons("visualization", this);
            renderStructure();
        }
      });

      $("#btn-ball-stick").click(function() {
        if (currentViewStyle !== "ballAndStick") {
            currentViewStyle = "ballAndStick";
            updateActiveButtons("visualization", this);
            renderStructure();
        }
      });

      $("#btn-spacefill").click(function() {
         if (currentViewStyle !== "spacefill") {
            currentViewStyle = "spacefill";
            updateActiveButtons("visualization", this);
            renderStructure();
         }
      });

      $("#btn-show-labels").click(function() {
        if (!labelsShown) {
            labelsShown = true;
            updateActiveButtons("labels", this);
            renderStructure(); // Redraw needed to add labels correctly
        }
      });

      $("#btn-hide-labels").click(function() {
        if (labelsShown) {
            labelsShown = false;
            updateActiveButtons("labels", this);
            renderStructure(); // Redraw needed to remove labels correctly
        }
      });

      $("#btn-show-cell").click(function() {
        if (!cellShown) {
            cellShown = true;
            updateActiveButtons("cell", this);
            renderStructure(); // Redraw needed to add cell outline
        }
      });

      $("#btn-hide-cell").click(function() {
        if (cellShown) {
            cellShown = false;
            updateActiveButtons("cell", this);
            renderStructure(); // Redraw needed to remove cell outline
        }
      });

      $("#btn-1x1x1").click(function() {
        if (currentSupercell !== 1) {
            currentSupercell = 1;
            updateActiveButtons("supercell", this);
            renderStructure(); // Redraw with new supercell size
        }
      });

      $("#btn-2x2x2").click(function() {
         if (currentSupercell !== 2) {
            currentSupercell = 2;
            updateActiveButtons("supercell", this);
            renderStructure(); // Redraw with new supercell size
         }
      });

      $("#btn-spin").click(function() {
        viewer.spin(true);
      });

      $("#btn-stop").click(function() {
        viewer.spin(false);
      });

      $("#btn-screenshot").click(function() {
        let imageData = viewer.pngURI();
        let link = document.createElement('a');
        link.download = 'HgCdTe-zincblende.png';
        link.href = imageData;
        document.body.appendChild(link); // Required for Firefox
        link.click();
        document.body.removeChild(link);
      });

      // Add resize listener
       $(window).on('resize', function() {
           viewer.resize();
       });
    });
  </script>
</body>
</html>
