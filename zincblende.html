<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HgCdTe Zincblende Structure Viewer</title>
  <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background-color: #fafafa;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #viewer {
      flex: 1;
      position: relative;
    }
    #controls {
      width: 270px;
      padding: 20px;
      background-color: white;
      border-left: 1px solid #eaeaea;
      overflow-y: auto;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
    }
    .control-group {
      margin-bottom: 20px;
    }
    .control-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }
    button {
      padding: 6px 12px;
      margin: 4px;
      cursor: pointer;
      background-color: #f5f5f5;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      transition: all 0.2s;
      font-size: 14px;
    }
    button:hover {
      background-color: #e9e9e9;
    }
    button.active {
      background-color: #e0e0e0;
      border-color: #c0c0c0;
    }
    .slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #e0e0e0;
      outline: none;
      border-radius: 3px;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #4a90e2;
      cursor: pointer;
    }
    .info-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      max-width: 300px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .info-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #333;
    }
    .legend {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      margin-right: 8px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    hr {
      border: none;
      border-top: 1px solid #eaeaea;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="viewer">
      <div class="info-panel">
        <h3>HgCdTe Zincblende Structure</h3>
        <div id="lattice-info">Lattice constant: 6.46 Å</div>
        <div id="composition-info">Composition: Hg<sub>0.7</sub>Cd<sub>0.3</sub>Te</div>
        <div>Space group: F-43m (216)</div>
        <hr>
        <div class="legend">
          <div class="legend-color" style="background-color:#FF5252;"></div>
          <div>Hg</div>
        </div>
        <div class="legend">
          <div class="legend-color" style="background-color:#FFD740;"></div>
          <div>Cd</div>
        </div>
        <div class="legend">
          <div class="legend-color" style="background-color:#40C4FF;"></div>
          <div>Te</div>
        </div>
      </div>
    </div>
    <div id="controls">
      <h2>Controls</h2>
      
      <div class="control-group">
        <div class="control-title">Composition (x in Hg₁₋ₓCdₓTe)</div>
        <input type="range" id="composition" class="slider" min="0" max="1" step="0.1" value="0.3">
        <div id="composition-value">x = 0.3</div>
      </div>
      
      <div class="control-group">
        <div class="control-title">Visualization</div>
        <button id="btn-stick">Stick</button>
        <button id="btn-ball-stick" class="active">Ball & Stick</button>
        <button id="btn-spacefill">Spacefill</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Unit Cell</div>
        <button id="btn-show-cell">Show Unit Cell</button>
        <button id="btn-hide-cell">Hide Unit Cell</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Labels</div>
        <button id="btn-show-labels">Show Labels</button>
        <button id="btn-hide-labels">Hide Labels</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Supercell</div>
        <button id="btn-1x1x1" class="active">1×1×1</button>
        <button id="btn-2x2x2">2×2×2</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Animation</div>
        <button id="btn-spin">Spin</button>
        <button id="btn-stop">Stop</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Export</div>
        <button id="btn-screenshot">Screenshot</button>
      </div>
      
      <div class="control-group">
        <div class="control-title">Structure Information</div>
        <p><strong>HgCdTe (Hg₁₋ₓCdₓTe)</strong></p>
        <p>- Ternary semiconductor alloy</p>
        <p>- Zincblende structure (F-43m)</p>
        <p>- Used in infrared detectors</p>
        <p>- Bandgap: 0 to 1.5 eV (tunable)</p>
        <p>- Applications: IR imaging, photonics</p>
      </div>
    </div>
  </div>

  <script>
    $(document).ready(function() {
      // Initialize the viewer
      let element = $("#viewer");
      let config = {
        backgroundColor: "white",
        antialias: true
      };
      
      let viewer = $3Dmol.createViewer(element, config);
      
      // Define lattice constants for HgTe and CdTe
      let a_HgTe = 6.46;  // Å
      let a_CdTe = 6.48;  // Å
      let latticeConstant = a_HgTe;  // Initial value
      
      // HgCdTe colors - Brighter scheme
      const atomColors = {
        "Hg": "#FF5252",  // Bright red
        "Cd": "#FFD740",  // Bright gold/yellow
        "Te": "#40C4FF"   // Bright blue
      };
      
      // Define radii
      const atomRadii = {
        "Hg": 1.5,
        "Cd": 1.4,
        "Te": 1.4
      };
      
      // Track if labels and cell are shown
      let labelsShown = false;
      let cellShown = false;
      let atomLabels = [];
      let cellLabel = null;
      let cellLines = [];
      
      // Current state tracking
      let currentViewStyle = "ballAndStick";
      let currentSupercell = 1;
      
      // Function to generate a zincblende structure for HgCdTe
      function generateZincblende(cdRatio = 0.3, cellSize = 1) {
        // Clear previous structure
        viewer.removeAllModels();
        viewer.removeAllShapes();
        if (labelsShown) {
          for (let label of atomLabels) {
            viewer.removeLabel(label);
          }
          atomLabels = [];
        }
        if (cellShown) {
          for (let line of cellLines) {
            viewer.removeShape(line);
          }
          cellLines = [];
          if (cellLabel) {
            viewer.removeLabel(cellLabel);
            cellLabel = null;
          }
        }
        
        // Initialize atoms array
        let atoms = [];
        
        // Generate supercell
        for (let i = 0; i < cellSize; i++) {
          for (let j = 0; j < cellSize; j++) {
            for (let k = 0; k < cellSize; k++) {
              // Base positions for zincblende structure (fractional coordinates)
              // Cation positions (Hg/Cd)
              let cationPositions = [
                [0, 0, 0],
                [0, 0.5, 0.5],
                [0.5, 0, 0.5],
                [0.5, 0.5, 0]
              ];
              
              // Anion positions (Te)
              let anionPositions = [
                [0.25, 0.25, 0.25],
                [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75],
                [0.75, 0.75, 0.25]
              ];
              
              // Add cations (Hg and Cd based on composition)
              for (let pos of cationPositions) {
                // Determine if this atom is Hg or Cd based on the ratio
                let elemType = Math.random() < cdRatio ? "Cd" : "Hg";
                
                atoms.push({
                  elem: elemType,
                  x: (pos[0] + i) * latticeConstant,
                  y: (pos[1] + j) * latticeConstant,
                  z: (pos[2] + k) * latticeConstant
                });
              }
              
              // Add anions (Te)
              for (let pos of anionPositions) {
                atoms.push({
                  elem: "Te",
                  x: (pos[0] + i) * latticeConstant,
                  y: (pos[1] + j) * latticeConstant,
                  z: (pos[2] + k) * latticeConstant
                });
              }
            }
          }
        }
        
        return atoms;
      }
      
      // Function to add bonds between atoms
      function addBonds(atoms) {
        const bondCutoff = 3.0; // Maximum distance for bonding (Angstroms)
        
        // Create bonds between close atoms
        for (let i = 0; i < atoms.length; i++) {
          for (let j = i + 1; j < atoms.length; j++) {
            const atom1 = atoms[i];
            const atom2 = atoms[j];
            
            // Skip bonds between same element types (cation-cation or anion-anion)
            if ((atom1.elem === "Hg" || atom1.elem === "Cd") && 
                (atom2.elem === "Hg" || atom2.elem === "Cd")) {
              continue;
            }
            if (atom1.elem === "Te" && atom2.elem === "Te") {
              continue;
            }
            
            // Calculate distance
            const dx = atom1.x - atom2.x;
            const dy = atom1.y - atom2.y;
            const dz = atom1.z - atom2.z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            // Add bond if within cutoff
            if (distance < bondCutoff) {
              viewer.addCylinder({
                start: { x: atom1.x, y: atom1.y, z: atom1.z },
                end: { x: atom2.x, y: atom2.y, z: atom2.z },
                radius: 0.1,  // Thinner bonds
                color: "#AAAAAA",
                fromCap: true,
                toCap: true
              });
            }
          }
        }
      }
      
      // Function to add atom labels with improved positioning
      function addLabels(atoms, center) {
        // Clear previous atom labels
        for (let label of atomLabels) {
          viewer.removeLabel(label);
        }
        atomLabels = [];
        
        atoms.forEach(atom => {
          // Calculate vector from center to atom
          let dx = atom.x - center.x;
          let dy = atom.y - center.y;
          let dz = atom.z - center.z;
          let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
          if (dist > 0) {
            dx /= dist;
            dy /= dist;
            dz /= dist;
          } else {
            dx = 1;
            dy = 0;
            dz = 0;
          }
          const offset = 1.5;  // Offset distance
          const labelPos = {
            x: atom.x + dx * offset,
            y: atom.y + dy * offset,
            z: atom.z + dz * offset
          };
          
          let labelId = viewer.addLabel(atom.elem, {
            position: labelPos,
            backgroundColor: "rgba(255, 255, 255, 0.7)",
            fontColor: "#333333",
            fontSize: 12,
            showBackground: true,
            backgroundOpacity: 0.5
          });
          atomLabels.push(labelId);
        });
      }
      
      // Function to draw unit cell
      function drawUnitCell(cellSize) {
        const cellLength = latticeConstant * cellSize;
        
        // Remove previous cell lines and label
        for (let line of cellLines) {
          viewer.removeShape(line);
        }
        cellLines = [];
        if (cellLabel) {
          viewer.removeLabel(cellLabel);
          cellLabel = null;
        }
        
        // Define cell vertices
        const vertices = [
          [0, 0, 0], [cellLength, 0, 0], [0, cellLength, 0], [cellLength, cellLength, 0],
          [0, 0, cellLength], [cellLength, 0, cellLength], [0, cellLength, cellLength], [cellLength, cellLength, cellLength]
        ];
        
        // Define edges
        const edges = [
          [0, 1], [0, 2], [1, 3], [2, 3],
          [4, 5], [4, 6], [5, 7], [6, 7],
          [0, 4], [1, 5], [2, 6], [3, 7]
        ];
        
        // Draw cell edges as dashed lines
        edges.forEach(edge => {
          const start = vertices[edge[0]];
          const end = vertices[edge[1]];
          
          // Calculate length and direction for dashed line
          const dx = end[0] - start[0];
          const dy = end[1] - start[1];
          const dz = end[2] - start[2];
          const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
          
          // Create dashed line (segments)
          const dashLength = 0.5;  // Length of each dash
          const gapLength = 0.5;   // Length of each gap
          const dashCount = Math.floor(length / (dashLength + gapLength));
          
          for (let i = 0; i < dashCount; i++) {
            const startFrac = i * (dashLength + gapLength) / length;
            const endFrac = (i * (dashLength + gapLength) + dashLength) / length;
            
            const dashStart = {
              x: start[0] + dx * startFrac,
              y: start[1] + dy * startFrac,
              z: start[2] + dz * startFrac
            };
            
            const dashEnd = {
              x: start[0] + dx * endFrac,
              y: start[1] + dy * endFrac,
              z: start[2] + dz * endFrac
            };
            
            let lineId = viewer.addCylinder({
              start: dashStart,
              end: dashEnd,
              radius: 0.05,
              color: "#888888",
              fromCap: true,
              toCap: true
            });
            cellLines.push(lineId);
          }
        });
        
        // Add lattice constant label
        let labelId = viewer.addLabel(`a = ${latticeConstant.toFixed(2)} Å`, {
          position: { x: cellLength / 2, y: -1.5, z: -1.5 },
          backgroundColor: "rgba(255, 255, 255, 0.8)",
          fontColor: "#333333",
          fontSize: 14,
          showBackground: true,
          backgroundOpacity: 0.8
        });
        cellLabel = labelId;
      }
      
      // Function to render the structure
      function renderStructure(viewStyle = "ballAndStick") {
        // Get the composition value
        let cdRatio = parseFloat($("#composition").val());
        $("#composition-value").text(`x = ${cdRatio.toFixed(1)}`);
        $("#composition-info").html(`Composition: Hg<sub>${(1-cdRatio).toFixed(1)}</sub>Cd<sub>${cdRatio.toFixed(1)}</sub>Te`);
        
        // Calculate lattice constant based on composition
        latticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;
        $("#lattice-info").text(`Lattice constant: ${latticeConstant.toFixed(2)} Å`);
        
        // Generate atoms
        let atoms = generateZincblende(cdRatio, currentSupercell);
        
        // Calculate center for label positioning
        let center = {
          x: (currentSupercell * latticeConstant) / 2,
          y: (currentSupercell * latticeConstant) / 2,
          z: (currentSupercell * latticeConstant) / 2
        };
        
        // Render different visualization styles
        switch(viewStyle) {
          case "stick":
            // Render atoms as small spheres
            atoms.forEach(atom => {
              viewer.addSphere({
                center: { x: atom.x, y: atom.y, z: atom.z },
                radius: 0.4,
                color: atomColors[atom.elem],
                opacity: 1.0
              });
            });
            // Add bonds
            addBonds(atoms);
            break;
            
          case "ballAndStick":
            // Render atoms as spheres
            atoms.forEach(atom => {
              viewer.addSphere({
                center: { x: atom.x, y: atom.y, z: atom.z },
                radius: atomRadii[atom.elem] * 0.6,
                color: atomColors[atom.elem],
                opacity: 1.0
              });
            });
            // Add bonds
            addBonds(atoms);
            break;
            
          case "spacefill":
            // Render atoms as large spheres
            atoms.forEach(atom => {
              viewer.addSphere({
                center: { x: atom.x, y: atom.y, z: atom.z },
                radius: atomRadii[atom.elem],
                color: atomColors[atom.elem],
                opacity: 1.0
              });
            });
            break;
        }
        
        // Add labels if they are enabled
        if (labelsShown) {
          addLabels(atoms, center);
        }
        
        // Add unit cell if it is enabled
        if (cellShown) {
          drawUnitCell(currentSupercell);
        }
        
        // Update view
        viewer.zoomTo();
        viewer.render();
      }
      
      // Function to update active button styling
      function updateActiveButtons(group, activeButton) {
        if (group === "visualization") {
          $("#btn-stick").removeClass("active");
          $("#btn-ball-stick").removeClass("active");
          $("#btn-spacefill").removeClass("active");
        } else if (group === "supercell") {
          $("#btn-1x1x1").removeClass("active");
          $("#btn-2x2x2").removeClass("active");
        }
        $(activeButton).addClass("active");
      }
      
      // Initial render
      renderStructure(currentViewStyle);
      
      // Event listeners for controls
      $("#composition").on("input", function() {
        renderStructure(currentViewStyle);
      });
      
      $("#btn-stick").click(function() {
        currentViewStyle = "stick";
        updateActiveButtons("visualization", this);
        renderStructure(currentViewStyle);
      });
      
      $("#btn-ball-stick").click(function() {
        currentViewStyle = "ballAndStick";
        updateActiveButtons("visualization", this);
        renderStructure(currentViewStyle);
      });
      
      $("#btn-spacefill").click(function() {
        currentViewStyle = "spacefill";
        updateActiveButtons("visualization", this);
        renderStructure(currentViewStyle);
      });
      
      $("#btn-show-labels").click(function() {
        labelsShown = true;
        let cdRatio = parseFloat($("#composition").val());
        let atoms = generateZincblende(cdRatio, currentSupercell);
        let center = {
          x: (currentSupercell * latticeConstant) / 2,
          y: (currentSupercell * latticeConstant) / 2,
          z: (currentSupercell * latticeConstant) / 2
        };
        addLabels(atoms, center);
        viewer.render();
      });
      
      $("#btn-hide-labels").click(function() {
        labelsShown = false;
        for (let label of atomLabels) {
          viewer.removeLabel(label);
        }
        atomLabels = [];
        viewer.render();
      });
      
      $("#btn-show-cell").click(function() {
        cellShown = true;
        drawUnitCell(currentSupercell);
        viewer.render();
      });
      
      $("#btn-hide-cell").click(function() {
        cellShown = false;
        for (let line of cellLines) {
          viewer.removeShape(line);
        }
        cellLines = [];
        if (cellLabel) {
          viewer.removeLabel(cellLabel);
          cellLabel = null;
        }
        viewer.render();
      });
      
      $("#btn-1x1x1").click(function() {
        currentSupercell = 1;
        updateActiveButtons("supercell", this);
        renderStructure(currentViewStyle);
      });
      
      $("#btn-2x2x2").click(function() {
        currentSupercell = 2;
        updateActiveButtons("supercell", this);
        renderStructure(currentViewStyle);
      });
      
      $("#btn-spin").click(function() {
        viewer.spin(true);
      });
      
      $("#btn-stop").click(function() {
        viewer.spin(false);
      });
      
      $("#btn-screenshot").click(function() {
        let imageData = viewer.pngURI();
        let link = document.createElement('a');
        link.download = 'HgCdTe-zincblende.png';
        link.href = imageData;
        link.click();
      });
    });
  </script>
</body>
</html>
