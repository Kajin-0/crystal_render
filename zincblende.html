<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HgCdTe Zincblende Structure Viewer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/3dmol/2.1.0/3Dmol-min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <style>
    /* Styles remain the same as the previous version */
    body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background-color: #fafafa; display: flex; height: 100vh; }
    #container { display: flex; flex-grow: 1; height: 100%; }
    #viewer { flex: 1; position: relative; min-width: 0; }
    #controls { width: 280px; flex-shrink: 0; padding: 20px; background-color: white; border-left: 1px solid #eaeaea; overflow-y: auto; box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05); }
    .control-group { margin-bottom: 25px; }
    .control-title { font-weight: 600; margin-bottom: 10px; color: #333; font-size: 0.95em; }
    button { padding: 7px 14px; margin: 4px 2px; cursor: pointer; background-color: #f5f5f5; border: 1px solid #dcdcdc; border-radius: 4px; transition: background-color 0.2s, border-color 0.2s; font-size: 14px; }
    button:hover { background-color: #e9e9e9; border-color: #c9c9c9; }
    button.active { background-color: #e0e0e0; border-color: #b0b0b0; font-weight: 600; }
    .slider { width: 100%; height: 6px; -webkit-appearance: none; appearance: none; background: #e0e0e0; outline: none; border-radius: 3px; cursor: pointer; }
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #4a90e2; cursor: pointer; }
    .slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #4a90e2; cursor: pointer; border: none; }
    #composition-value { text-align: center; margin-top: 8px; font-size: 0.9em; color: #555; }
    .info-panel { position: absolute; bottom: 15px; left: 15px; background-color: rgba(255, 255, 255, 0.92); padding: 12px 15px; border-radius: 6px; font-size: 13px; max-width: 280px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); z-index: 100; }
    .info-panel h3 { margin-top: 0; margin-bottom: 8px; color: #222; font-size: 1.1em; }
    .legend { display: flex; align-items: center; margin-bottom: 6px; }
    .legend-color { width: 14px; height: 14px; margin-right: 8px; border-radius: 50%; border: 1px solid rgba(0, 0, 0, 0.1); flex-shrink: 0; }
    hr { border: none; border-top: 1px solid #eaeaea; margin: 12px 0; }
    .structure-info p { font-size: 0.85em; line-height: 1.4; margin: 4px 0; color: #444; }
    .structure-info p > strong { color: #111; }
  </style>
</head>
<body>
  <div id="viewer">
    <div class="info-panel">
      <h3>HgCdTe Zincblende Structure</h3>
      <div id="lattice-info">Lattice constant: ... Å</div>
      <div id="composition-info">Composition: ...</div>
      <div>Space group: F-43m (216)</div>
      <hr>
      <div class="legend"> <div class="legend-color" style="background-color:#E000E0;"></div> <div>Hg (Magenta)</div> </div>
      <div class="legend"> <div class="legend-color" style="background-color:#CCCCCC;"></div> <div>Cd (Light Grey)</div> </div>
      <div class="legend"> <div class="legend-color" style="background-color:#33CC33;"></div> <div>Te (Green)</div> </div>
    </div>
  </div>
  <div id="controls">
     <!-- Controls remain the same as the previous version -->
    <h2>Controls</h2>
    <div class="control-group"> <div class="control-title">Composition (x in Hg₁₋ₓCdₓTe)</div> <input type="range" id="composition" class="slider" min="0" max="1" step="0.05" value="0.3"> <div id="composition-value">x = 0.30</div> </div>
    <div class="control-group"> <div class="control-title">Visualization Style</div> <button id="btn-stick">Stick</button> <button id="btn-ball-stick">Ball & Stick</button> <button id="btn-spacefill">Spacefill</button> </div>
    <div class="control-group"> <div class="control-title">Unit Cell Box</div> <button id="btn-show-cell">Show Box</button> <button id="btn-hide-cell">Hide Box</button> </div>
    <div class="control-group"> <div class="control-title">Atom Labels (Unit Cell Only)</div> <button id="btn-show-labels">Show Labels</button> <button id="btn-hide-labels">Hide Labels</button> </div>
    <div class="control-group"> <div class="control-title">Supercell Size</div> <button id="btn-1x1x1">1×1×1</button> <button id="btn-2x2x2">2×2×2</button> </div>
    <div class="control-group"> <div class="control-title">Animation</div> <button id="btn-spin">Spin</button> <button id="btn-stop">Stop</button> </div>
    <div class="control-group"> <div class="control-title">Export</div> <button id="btn-screenshot">Screenshot (PNG)</button> </div>
    <div class="control-group structure-info"> <div class="control-title">Structure Information</div> <p><strong>Hg₁₋ₓCdₓTe (MCT)</strong></p> <p>- Ternary semiconductor alloy</p> <p>- Zincblende structure (F-43m)</p> <p>- Vegard's Law approx. for lattice</p> <p>- Used in infrared detectors</p> <p>- Tunable Bandgap: ~0 to 1.5 eV</p> </div>
  </div>

  <script>
    $(document).ready(function() {
      // Initialize the viewer
      const element = $("#viewer");
      const config = { backgroundColor: "white", antialias: true, quality: 'high' };
      const viewer = $3Dmol.createViewer(element, config);

      // Constants
      const A_HGTE = 6.461; const A_CDTE = 6.482;
      const ATOM_COLORS = { "Hg": "#E000E0", "Cd": "#CCCCCC", "Te": "#33CC33" };
      const BASIS_CATIONS = [[0,0,0], [0,0.5,0.5], [0.5,0,0.5], [0.5,0.5,0]];
      const BASIS_ANIONS = [[0.25,0.25,0.25], [0.25,0.75,0.75], [0.75,0.25,0.75], [0.75,0.75,0.25]];

      // State variables
      let latticeConstant = A_HGTE;
      let labelsShown = false;
      let cellShown = false;
      let currentViewStyle = "ballAndStick";
      let currentSupercell = 1;
      let currentAtoms = [];
      let activeLabels = [];
      let activeCellShapes = [];

      // Function to generate atom data
      function generateAtomData(cdRatio, supercellN) {
        console.log(`Generating atoms for x=${cdRatio.toFixed(2)}, N=${supercellN}...`);
        const atoms = [];
        const currentLatticeConstant = A_HGTE * (1 - cdRatio) + A_CDTE * cdRatio;
        latticeConstant = currentLatticeConstant; // Update global state

        let serialCounter = 0;
        let hasNaN = false; // Flag for checking coordinates

        for (let i = 0; i < supercellN; i++) {
          for (let j = 0; j < supercellN; j++) {
            for (let k = 0; k < supercellN; k++) {
              BASIS_CATIONS.forEach(pos => {
                const elemType = Math.random() < cdRatio ? "Cd" : "Hg";
                const x = (pos[0] + i) * currentLatticeConstant;
                const y = (pos[1] + j) * currentLatticeConstant;
                const z = (pos[2] + k) * currentLatticeConstant;
                if (isNaN(x) || isNaN(y) || isNaN(z)) hasNaN = true;
                atoms.push({ serial: serialCounter++, elem: elemType, x: x, y: y, z: z });
              });
              BASIS_ANIONS.forEach(pos => {
                const x = (pos[0] + i) * currentLatticeConstant;
                const y = (pos[1] + j) * currentLatticeConstant;
                const z = (pos[2] + k) * currentLatticeConstant;
                if (isNaN(x) || isNaN(y) || isNaN(z)) hasNaN = true;
                atoms.push({ serial: serialCounter++, elem: "Te", x: x, y: y, z: z });
              });
            }
          }
        }

        if(hasNaN) {
            console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.error("!!! NaN coordinates generated in atoms !!!");
            console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            // Optionally return an empty array or throw an error
            // return [];
        }

        console.log(`Generated ${atoms.length} atoms. First atom:`, JSON.stringify(atoms[0]));
        console.log("Generation complete.");
        return atoms;
      }

      // --- Drawing Functions ---
       function removeCurrentLabels() {
         activeLabels.forEach(label => { if (label) viewer.removeLabel(label); });
         activeLabels = [];
       }

       function addAtomLabelsToView() {
         removeCurrentLabels();
         if (!labelsShown || !currentAtoms || currentAtoms.length === 0) return;
         console.log("Adding labels...");
         const baseCellLimit = latticeConstant;
         const labelStyle = { backgroundColor: "rgba(255,255,255,0.75)", fontColor: "#111111", fontSize: 11, showBackground: true, backgroundOpacity: 0.6, borderWidth: 0.5, borderColor: 'grey' };
         let addedCount = 0;
         currentAtoms.forEach(atom => {
           if (atom.x >= -1e-6 && atom.x < baseCellLimit && atom.y >= -1e-6 && atom.y < baseCellLimit && atom.z >= -1e-6 && atom.z < baseCellLimit) {
             try {
               const label = viewer.addLabel(atom.elem, { ...labelStyle, position: { x: atom.x, y: atom.y, z: atom.z } });
               if (label) { activeLabels.push(label); addedCount++; }
             } catch (e) { console.error("Error adding label:", e); }
           }
         });
         console.log(`Added ${addedCount} labels.`);
         viewer.render(); // Render label changes immediately
       }

       function removeCurrentCellOutline() {
         activeCellShapes.forEach(shape => { if (shape) viewer.removeShape(shape); });
         activeCellShapes = [];
       }

       function drawUnitCellOutline() {
         removeCurrentCellOutline();
         if (!cellShown) return;
         console.log("Drawing cell outline...");
         const cellLength = latticeConstant * currentSupercell;
         const lineStyle = { radius: 0.04, color: "#444444", dashed: true, dashLength: 0.3, gapLength: 0.2 };
         const vertices = [ {x:0, y:0, z:0}, {x:cellLength, y:0, z:0}, {x:0, y:cellLength, z:0}, {x:cellLength, y:cellLength, z:0}, {x:0, y:0, z:cellLength}, {x:cellLength, y:0, z:cellLength}, {x:0, y:cellLength, z:cellLength}, {x:cellLength, y:cellLength, z:cellLength} ];
         const edges = [ [0,1], [0,2], [1,3], [2,3], [4,5], [4,6], [5,7], [6,7], [0,4], [1,5], [2,6], [3,7] ];
         let addedCount = 0;
         edges.forEach(edgeIndices => {
           const start = vertices[edgeIndices[0]]; const end = vertices[edgeIndices[1]];
           try {
             const shape = viewer.addCylinder({ start: start, end: end, ...lineStyle });
             if (shape) { activeCellShapes.push(shape); addedCount++; }
           } catch (e) { console.error("Error adding cell cylinder:", e); }
         });
         console.log(`Added ${addedCount} cell shapes.`);
         viewer.render(); // Render shape changes immediately
       }

      // --- CORE RENDERING FUNCTION ---
      function renderStructure() {
        console.log("--- Starting renderStructure ---");
        // Clear previous state thoroughly
        viewer.removeAllModels();
        viewer.removeAllShapes();
        viewer.removeAllLabels();
        activeLabels = [];
        activeCellShapes = [];

        if (!currentAtoms || currentAtoms.length === 0) {
          console.warn("renderStructure: No atoms to render.");
          viewer.render(); // Render empty if needed
          return;
        }
        if (currentAtoms.some(a => isNaN(a.x) || isNaN(a.y) || isNaN(a.z))) {
            console.error("renderStructure: NaN coordinates detected. Aborting render.");
            return; // Stop if data is bad
        }

        console.log(`renderStructure: Adding ${currentAtoms.length} atoms to model.`);
        const model = viewer.addModel();
        model.addAtoms(currentAtoms);
        console.log("renderStructure: Model added.");

        // Define visualization styles
        const baseStickRadius = 0.08;
        const ballScale = 0.30;
        // Use a very small, non-zero scale for spheres in stick mode
        const stickModeAtomScale = 0.01; // Was 0.1, trying smaller

        let styleSpec = {};
        const colorScheme = { prop: 'elem', map: ATOM_COLORS };

        // *** Style adjustments for debugging visibility ***
        switch (currentViewStyle) {
          case "stick":
            styleSpec = {
              stick: {
                radius: baseStickRadius,
                colorscheme: colorScheme,
                bonds: 10 // Keep trying numeric bonds here
              },
              sphere: {
                 scale: stickModeAtomScale, // VERY small spheres, but not zero
                 colorscheme: colorScheme
              }
            };
            console.log("renderStructure: Applying STICK style (bonds=10, tiny spheres).");
            break;
          case "ballAndStick":
            styleSpec = {
              stick: {
                radius: baseStickRadius,
                colorscheme: colorScheme
                // bonds: 0 // DEFAULT bonding based on proximity, REMOVED explicit bonds:10 for testing
              },
              sphere: {
                scale: ballScale,
                colorscheme: colorScheme
              }
            };
             console.log("renderStructure: Applying BALL & STICK style (DEFAULT bonds).");
            break;
          case "spacefill":
            styleSpec = {
              sphere: { colorscheme: colorScheme, scale: 1.0 }
              // No bonds needed for spacefill
            };
            console.log("renderStructure: Applying SPACEFILL style.");
            break;
          default:
            console.error("renderStructure: Unknown currentViewStyle:", currentViewStyle);
            styleSpec = { sphere: { colorscheme: colorScheme, scale: 0.5 } }; // Fallback
            break;
        }

        console.log("renderStructure: Setting style:", JSON.stringify(styleSpec));
        viewer.setStyle({}, styleSpec);
        console.log("renderStructure: Style applied.");

        // Re-add labels and cell outline if requested (AFTER styling)
        if (cellShown) {
          console.log("renderStructure: Calling drawUnitCellOutline...");
          drawUnitCellOutline(); // Will also call render
        }
        if (labelsShown) {
          console.log("renderStructure: Calling addAtomLabelsToView...");
          addAtomLabelsToView(); // Will also call render
        }

        console.log("renderStructure: Calling zoomTo...");
        viewer.zoomTo();
        console.log("renderStructure: Calling final render...");
        viewer.render();
        console.log("--- renderStructure Complete ---");
      }

      // --- Update UI Functions ---
      function updateInfoPanel() { /* same as before */
          const cdRatio = parseFloat($("#composition").val());
          $("#composition-info").html(`Composition: Hg<sub>${(1 - cdRatio).toFixed(2)}</sub>Cd<sub>${cdRatio.toFixed(2)}</sub>Te`);
          $("#lattice-info").text(`Lattice constant (a): ${latticeConstant.toFixed(3)} Å`);
      }
      function updateCompositionDisplay() { /* same as before */
          const cdRatio = parseFloat($("#composition").val());
           $("#composition-value").text(`x = ${cdRatio.toFixed(2)}`);
      }
      function updateActiveButtons(groupSelector, activeButton) { /* same as before */
        $(groupSelector).removeClass("active");
        $(activeButton).addClass("active");
      }

      // --- Combined Action Functions ---
      function regenerateAndRender() {
          console.log(">>> Regenerate & Render <<<");
          const cdRatio = parseFloat($("#composition").val());
          updateCompositionDisplay();
          currentAtoms = generateAtomData(cdRatio, currentSupercell);
          updateInfoPanel();
          renderStructure(); // Render the new atoms/styles
      }

      function redrawView() {
          console.log(">>> Redraw View <<<");
          // Assumes currentAtoms is valid, just reapply styles/shapes/labels
          renderStructure();
      }

      // --- Event Listeners ---
      // Composition Slider
      $("#composition").on("input", updateCompositionDisplay); // Update text while sliding
      $("#composition").on("change", regenerateAndRender); // Regenerate on release

      // Supercell Buttons
      $("#btn-1x1x1").click(function() { if (currentSupercell !== 1) { currentSupercell = 1; updateActiveButtons("#btn-1x1x1, #btn-2x2x2", this); regenerateAndRender(); } });
      $("#btn-2x2x2").click(function() { if (currentSupercell !== 2) { currentSupercell = 2; updateActiveButtons("#btn-1x1x1, #btn-2x2x2", this); regenerateAndRender(); } });

      // Visualization Style Buttons
      $("#btn-stick").click(function() { if (currentViewStyle !== "stick") { currentViewStyle = "stick"; updateActiveButtons("#btn-stick, #btn-ball-stick, #btn-spacefill", this); redrawView(); } });
      $("#btn-ball-stick").click(function() { if (currentViewStyle !== "ballAndStick") { currentViewStyle = "ballAndStick"; updateActiveButtons("#btn-stick, #btn-ball-stick, #btn-spacefill", this); redrawView(); } });
      $("#btn-spacefill").click(function() { if (currentViewStyle !== "spacefill") { currentViewStyle = "spacefill"; updateActiveButtons("#btn-stick, #btn-ball-stick, #btn-spacefill", this); redrawView(); } });

      // Label Buttons (Call specific add/remove functions directly)
      $("#btn-show-labels").click(function() { if (!labelsShown) { labelsShown = true; updateActiveButtons("#btn-show-labels, #btn-hide-labels", this); addAtomLabelsToView(); } });
      $("#btn-hide-labels").click(function() { if (labelsShown) { labelsShown = false; updateActiveButtons("#btn-show-labels, #btn-hide-labels", this); removeCurrentLabels(); viewer.render(); /* Render needed after removal */ } });

      // Unit Cell Box Buttons (Call specific add/remove functions directly)
      $("#btn-show-cell").click(function() { if (!cellShown) { cellShown = true; updateActiveButtons("#btn-show-cell, #btn-hide-cell", this); drawUnitCellOutline(); } });
      $("#btn-hide-cell").click(function() { if (cellShown) { cellShown = false; updateActiveButtons("#btn-show-cell, #btn-hide-cell", this); removeCurrentCellOutline(); viewer.render(); /* Render needed after removal */ } });

      // Animation Buttons
      $("#btn-spin").click(function() { viewer.spin(true); });
      $("#btn-stop").click(function() { viewer.spin(false); });

      // Screenshot Button
      $("#btn-screenshot").click(function() { /* same as before */
        const imageData = viewer.pngURI(); const link = document.createElement('a');
        const cdRatio = parseFloat($("#composition").val());
        link.download = `HgCdTe_x${cdRatio.toFixed(2)}_${currentSupercell}x${currentSupercell}.png`;
        link.href = imageData; document.body.appendChild(link); link.click(); document.body.removeChild(link);
      });

      // Resize listener
      $(window).on('resize', function() { viewer.resize(); });

      // --- Initial Load ---
      function initialize() {
        console.log(">>> Initializing Application <<<");
        // Set initial active buttons visually
        updateActiveButtons("#btn-stick, #btn-ball-stick, #btn-spacefill", "#btn-ball-stick"); // Default to Ball & Stick
        updateActiveButtons("#btn-1x1x1, #btn-2x2x2", "#btn-1x1x1");
        updateActiveButtons("#btn-show-labels, #btn-hide-labels", "#btn-hide-labels");
        updateActiveButtons("#btn-show-cell, #btn-hide-cell", "#btn-hide-cell");

        // Set initial state variables explicitly
        currentViewStyle = "ballAndStick"; // Start with Ball & Stick
        currentSupercell = 1;
        labelsShown = false;
        cellShown = false;

        // Perform the initial generation and rendering
        regenerateAndRender();
        console.log(">>> Initialization Complete <<<");
      }

      initialize(); // Run initialization

    }); // End document ready
  </script>
</body>
</html>
