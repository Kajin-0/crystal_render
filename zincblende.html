      // *** CORE RENDERING FUNCTION (Uses existing currentAtoms) ***
      function renderCore() {
        viewer.removeAllModels(); viewer.removeAllShapes();
        for (let label of atomLabels) viewer.removeLabel(label); atomLabels = [];
        for (let lineId of cellLines) viewer.removeShape(lineId); cellLines = [];
        if (cellLabel) viewer.removeLabel(cellLabel); cellLabel = null;

        if (!currentAtoms || currentAtoms.length === 0) { viewer.render(); return; }

        let cdRatio = parseFloat($("#composition").val());
        // Update lattice constant used for display/labels here if needed, though generation uses the correct one
        const displayLatticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;
        $("#composition-info").html(`Composition: Hg<sub>${(1-cdRatio).toFixed(1)}</sub>Cd<sub>${cdRatio.toFixed(1)}</sub>Te`);
        $("#lattice-info").text(`Lattice constant: ${displayLatticeConstant.toFixed(2)} Å`); // Use the calculated value

        let model = viewer.addModel();
        model.addAtoms(currentAtoms);

        // --- Explicitly compute bonds after adding atoms ---
        // Although usually automatic, let's try adding this step
        // if sticks are still missing. If they appear *with* this line
        // but not without, it points to a subtle issue.
        // If they appear *without* this line after the style fix below,
        // then this line is not needed.
        // model.computeBonds(); // <<< TRY ADDING THIS LINE TEMPORARILY IF NEEDED

        let style = {};
        const baseStickRadius = 0.1; const ballScale = 0.35; const stickModeAtomScale = 0.05;
        const colorScheme = { prop: 'elem', map: atomColors };

        // Define the styles cleanly
        const sphereStyle = { colorscheme: colorScheme };
        const stickStyle = { radius: baseStickRadius, colorscheme: colorScheme }; // No 'bonds: 0'

        switch (currentViewStyle) {
          case "stick":
            style = {
              stick: stickStyle,
              sphere: { ...sphereStyle, scale: stickModeAtomScale } // Use spread syntax for clarity
            }; break;
          case "ballAndStick":
            style = {
              stick: stickStyle,
              sphere: { ...sphereStyle, scale: ballScale } // Use spread syntax for clarity
            }; break;
          case "spacefill":
            // For spacefill, we only define sphere style. No explicit stick style needed.
            style = { sphere: { ...sphereStyle, scale: 1.0 } }; // Often scale is 1.0 or omitted for default vdw
            break;
        }

        // Apply the style to all atoms ({}) in the viewer
        viewer.setStyle({}, style);

        // --- Make sure atom properties needed for bonding are present ---
        // 3Dmol uses element type ('elem') to determine bonding radii.
        // Your generateAtomData looks correct as it includes 'elem'.

        if (cellShown) drawUnitCellOutline(); // Use displayLatticeConstant if cell drawing depends on it
        if (labelsShown) addAtomLabels(); // Ensure labels use the correct coordinates/constants

        viewer.zoomTo();
        viewer.render();
      }

      // *** Function to Regenerate Atoms AND Render ***
      function regenerateAndRender() {
        let cdRatio = parseFloat($("#composition").val());
        // This latticeConstant is used for generating positions
        latticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;
        $("#composition-value").text(`x = ${cdRatio.toFixed(1)}`);
        currentAtoms = generateAtomData(cdRatio, currentSupercell); // uses the global latticeConstant
        renderCore(); // renderCore will read cdRatio again for display text
      }

      // Modify drawUnitCellOutline to use the potentially updated latticeConstant
       function drawUnitCellOutline() {
            for (let lineId of cellLines) viewer.removeShape(lineId);
            cellLines = [];
            if (cellLabel) viewer.removeLabel(cellLabel); cellLabel = null;
            if (!cellShown) return;

            // Use the *currently calculated* lattice constant for drawing
            let cdRatio = parseFloat($("#composition").val());
            const currentDisplayLatticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;

            const cellLength = currentDisplayLatticeConstant * currentSupercell; // Use current value
            const vertices = [ [0,0,0],[cellLength,0,0],[0,cellLength,0],[cellLength,cellLength,0], [0,0,cellLength],[cellLength,0,cellLength],[0,cellLength,cellLength],[cellLength,cellLength,cellLength] ];
            const edges = [ [0,1],[0,2],[1,3],[2,3],[4,5],[4,6],[5,7],[6,7],[0,4],[1,5],[2,6],[3,7] ];
            edges.forEach(edge => {
              const start = {x:vertices[edge[0]][0], y:vertices[edge[0]][1], z:vertices[edge[0]][2]};
              const end = {x:vertices[edge[1]][0], y:vertices[edge[1]][1], z:vertices[edge[1]][2]};
              let lineId = viewer.addCylinder({ start: start, end: end, radius: 0.05, color: "#555555", dashed: true, dashLength: 0.4, gapLength: 0.2 });
              cellLines.push(lineId);
            });
            if (currentSupercell === 1) {
              // Use currentDisplayLatticeConstant for the label
              cellLabel = viewer.addLabel(`a = ${currentDisplayLatticeConstant.toFixed(2)} Å`, { position:{x:cellLength/2, y:-1.0, z:-1.0}, backgroundColor:"rgba(255,255,255,0.8)", fontColor:"#333333", fontSize:14, showBackground:true, backgroundOpacity:0.8 });
            }
      }

        // Modify addAtomLabels if its logic depends on latticeConstant
        function addAtomLabels() {
            for (let label of atomLabels) viewer.removeLabel(label);
            atomLabels = [];
            if (!labelsShown || !currentAtoms || currentAtoms.length === 0) return;

            // Use the *currently calculated* lattice constant if needed for logic
            let cdRatio = parseFloat($("#composition").val());
            const currentDisplayLatticeConstant = a_HgTe * (1 - cdRatio) + a_CdTe * cdRatio;
            const baseCellLimit = currentDisplayLatticeConstant; // Use current value
            const center = { x: (currentSupercell*baseCellLimit)/2, y: (currentSupercell*baseCellLimit)/2, z: (currentSupercell*baseCellLimit)/2 };

            currentAtoms.forEach(atom => {
                // Check if atom is within the first unit cell for labeling
                if (atom.x < baseCellLimit && atom.y < baseCellLimit && atom.z < baseCellLimit &&
                    atom.x >= 0 && atom.y >= 0 && atom.z >= 0) { // Added >= 0 check for clarity

                    let dx = atom.x - center.x, dy = atom.y - center.y, dz = atom.z - center.z;
                    let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    const offsetFactor = 1.5;
                    let labelPos = { x: atom.x, y: atom.y, z: atom.z };

                    // Offset label position slightly away from the center
                    if (dist > 0.01) {
                        labelPos.x += (dx/dist)*offsetFactor;
                        labelPos.y += (dy/dist)*offsetFactor;
                        labelPos.z += (dz/dist)*offsetFactor;
                    } else {
                         // Handle atoms exactly at the center (though unlikely in this structure)
                         labelPos.x += offsetFactor;
                    }
                    let labelId = viewer.addLabel(atom.elem, { position: labelPos, backgroundColor: "rgba(255,255,255,0.7)", fontColor: "#333333", fontSize: 12, showBackground: true, backgroundOpacity: 0.5 });
                    atomLabels.push(labelId);
                }
            });
             viewer.render(); // Render after adding labels
        }
