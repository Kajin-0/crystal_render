<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HgCdTe Zincblende Structure (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; } /* Added background to body */
        canvas { display: block; }
        #info { /* Style for the info box */
            position: absolute;
            top: 10px;
            left: 10px;
            color: #000;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px; /* Slightly smaller text */
        }
        #info h2 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        #info p { margin: 5px 0; }
        #info ul { margin: 5px 0 5px 20px; padding: 0; }
        #info li { margin-bottom: 3px; }
    </style>
</head>
<body>
    <!-- No initial content, will be added by script -->

    <!-- Load Three.js FIRST -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r133/three.min.js"></script>
    <!-- Load OrbitControls SECOND (depends on Three.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r133/examples/js/controls/OrbitControls.js"></script>

    <script>
        // No need for window.load event listener now, as scripts load sequentially before this runs.

        // Check if libraries loaded correctly (optional but good practice)
        if (typeof THREE === 'undefined') {
            document.body.innerHTML = '<div style="color: red; padding: 20px;">Error: Three.js failed to load. Check script URL and network connection.</div>';
            throw new Error("Three.js failed to load");
        }
        if (typeof THREE.OrbitControls === 'undefined') {
            document.body.innerHTML = '<div style="color: red; padding: 20px;">Error: OrbitControls failed to load. Check script URL and network connection.</div>';
            throw new Error("OrbitControls failed to load");
        }

        // --- Three.js Scene Setup ---

        // Initialize the scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); // Light grey background

        // Initialize the camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); // Slightly less wide FOV
        camera.position.set(4, 4, 6); // Adjust starting position
        camera.lookAt(0, 0, 0);

        // Initialize the renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooths camera movement
        controls.dampingFactor = 0.1; // Adjust damping
        controls.minDistance = 1; // Prevent zooming too close
        controls.maxDistance = 50; // Prevent zooming too far

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Slightly stronger ambient
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5); // Light source position
        scene.add(directionalLight);

        // --- Crystal Structure Logic ---

        // Materials for atoms (Using MeshStandardMaterial for better lighting)
        const hgMaterial = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA, // Lighter grey for Mercury
            metalness: 0.5, roughness: 0.5
        });
        const cdMaterial = new THREE.MeshStandardMaterial({
            color: 0x4682B4, // SteelBlue for Cadmium
            metalness: 0.5, roughness: 0.5
        });
        const teMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700, // Gold for Tellurium (often used for Te/S)
            metalness: 0.2, roughness: 0.6
        });

        // Visual radii of atoms (adjust for desired look)
        const hgRadius = 0.18;
        const cdRadius = 0.16;
        const teRadius = 0.14;
        const sphereDetail = 16; // Lower detail for performance

        // Lattice constant (using 1.0 for relative positioning)
        const lattice_a = 1.0;

        // Geometry for atoms (create once, reuse)
        const hgGeometry = new THREE.SphereGeometry(hgRadius, sphereDetail, sphereDetail);
        const cdGeometry = new THREE.SphereGeometry(cdRadius, sphereDetail, sphereDetail);
        const teGeometry = new THREE.SphereGeometry(teRadius, sphereDetail, sphereDetail);

        // Function to create a single unit cell
        function createUnitCell() {
            const unitCellGroup = new THREE.Group();

            // --- Define atom positions within the unit cell (fractional coordinates * lattice_a) ---
            // Te positions (FCC base at origin + shifts)
            const tePositions = [
                [0.00, 0.00, 0.00], [0.00, 0.50, 0.50],
                [0.50, 0.00, 0.50], [0.50, 0.50, 0.00]
            ];

            // Hg/Cd positions (shifted FCC base)
            const cationPositions = [
                [0.25, 0.25, 0.25], [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75], [0.75, 0.75, 0.25]
            ];

            // --- Add Te atoms ---
            tePositions.forEach(pos => {
                const atom = new THREE.Mesh(teGeometry, teMaterial);
                atom.position.set(pos[0] * lattice_a, pos[1] * lattice_a, pos[2] * lattice_a);
                unitCellGroup.add(atom);
            });

            // --- Add Hg/Cd atoms (Randomly choose for alloy simulation) ---
            cationPositions.forEach(pos => {
                let atom;
                if (Math.random() > 0.5) { // Approx 50% Hg, 50% Cd
                    atom = new THREE.Mesh(hgGeometry, hgMaterial);
                } else {
                    atom = new THREE.Mesh(cdGeometry, cdMaterial);
                }
                atom.position.set(pos[0] * lattice_a, pos[1] * lattice_a, pos[2] * lattice_a);
                unitCellGroup.add(atom);
            });

            // --- Optional: Add unit cell wireframe ---
            // const boxGeom = new THREE.BoxGeometry(lattice_a, lattice_a, lattice_a);
            // const edges = new THREE.EdgesGeometry(boxGeom);
            // const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 1 })); // Dark grey lines
            // line.position.set(lattice_a / 2, lattice_a / 2, lattice_a / 2); // Center the box outline
            // unitCellGroup.add(line);

            return unitCellGroup;
        }

        // Function to create a supercell by replicating the unit cell
        function createSupercell(nx, ny, nz) {
            const supercellGroup = new THREE.Group();

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    for (let k = 0; k < nz; k++) {
                        const unitCell = createUnitCell();
                        // Position the corner of the unit cell
                        unitCell.position.set(i * lattice_a, j * lattice_a, k * lattice_a);
                        supercellGroup.add(unitCell);
                    }
                }
            }

            // Center the entire supercell group visually
            // Calculate the center offset based on the number of cells
            const centerOffset = new THREE.Vector3(
                (nx * lattice_a) / 2 - lattice_a / 2,
                (ny * lattice_a) / 2 - lattice_a / 2,
                (nz * lattice_a) / 2 - lattice_a / 2
            );
            // Apply the offset to all children (unit cells) to move the center to (0,0,0)
            supercellGroup.children.forEach(child => {
                child.position.sub(centerOffset);
            });


            // Add supercell bounding box (Optional)
             const supercellBoxSize = new THREE.Vector3(nx * lattice_a, ny * lattice_a, nz * lattice_a);
             const supercellBoxGeom = new THREE.BoxGeometry(supercellBoxSize.x, supercellBoxSize.y, supercellBoxSize.z);
             const supercellEdges = new THREE.EdgesGeometry(supercellBoxGeom);
             const supercellLine = new THREE.LineSegments(supercellEdges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })); // Black outline
             // No need to position the line - it's centered by default around the group's origin (0,0,0)
             supercellGroup.add(supercellLine);


            return supercellGroup;
        }

        // --- Create and Add the 2x2x2 Supercell ---
        const crystal = createSupercell(2, 2, 2);
        scene.add(crystal);

        // --- UI Setup ---
        function addUI() {
            const infoDiv = document.createElement('div');
            infoDiv.id = 'info'; // Use the ID defined in CSS
            infoDiv.innerHTML = `
                <h2>HgCdTe Zincblende (2x2x2)</h2>
                <p>Random alloy simulation using Three.js</p>
                <p>Legend:</p>
                <ul>
                    <li><span style="color: ${hgMaterial.color.getStyle()};">■</span> Mercury (Hg)</li>
                    <li><span style="color: ${cdMaterial.color.getStyle()};">■</span> Cadmium (Cd)</li>
                    <li><span style="color: ${teMaterial.color.getStyle()};">■</span> Tellurium (Te)</li>
                </ul>
                <p>Controls: Drag to rotate, Scroll to zoom</p>
            `;
            document.body.appendChild(infoDiv);
        }
        addUI(); // Add the info box to the page

        // --- Handle Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            controls.update(); // Update controls (needed for damping)
            renderer.render(scene, camera); // Render the scene
        }

        animate(); // Start the animation loop

    </script>
</body>
</html>
